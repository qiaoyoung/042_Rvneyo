
#import <Foundation/Foundation.h>

NSString *StringFromCurrent_Data(Byte *data);


//: tag
Byte appDuringResource[] = {77, 3, 12, 76, 147, 154, 191, 93, 126, 226, 105, 190, 103, 97, 116, 99};

//: file
Byte appFieldWhiteName[] = {92, 4, 12, 126, 222, 8, 112, 157, 89, 237, 19, 237, 101, 108, 105, 102, 52};

//: data
Byte layoutHighlightSlipHelper[] = {19, 4, 13, 232, 204, 223, 197, 59, 159, 157, 18, 117, 187, 97, 116, 97, 100, 207};

//: title
Byte moduleOutputID[] = {15, 5, 3, 101, 108, 116, 105, 116, 16};

//: info
Byte colorValleyToken[] = {8, 4, 11, 72, 214, 40, 104, 145, 7, 86, 198, 111, 102, 110, 105, 88};

//: normal
Byte userSliceVersion[] = {10, 6, 6, 115, 34, 202, 108, 97, 109, 114, 111, 110, 45};

//: gif
Byte styleLandDate[] = {64, 3, 13, 24, 90, 184, 189, 195, 74, 66, 243, 37, 130, 102, 105, 103, 96};

//: unicode
Byte cacheEntityPath[] = {4, 7, 10, 23, 20, 116, 109, 176, 55, 232, 101, 100, 111, 99, 105, 110, 117, 35};

//: pressed
Byte kStorageName[] = {31, 7, 4, 88, 100, 101, 115, 115, 101, 114, 112, 4};

// __DEBUG__
// __CLOSE_PRINT__
//
//  USEREmoticonManager.h
//  NIM
//
//  Created by amao on 7/2/14.
//  Copyright (c) 2014 Netease. All rights reserved.
//

// __M_A_C_R_O__
//: #import "DescriptionPerimeterStaggerBreezy.h"
#import "DescriptionPerimeterStaggerBreezy.h"
//: #import "DetectRestrictionWorldWithin.h"
#import "DetectRestrictionWorldWithin.h"
//: #import "NSString+InkwellValidateSplitShell.h"
#import "NSString+InkwellValidateSplitShell.h"
//: #import "InkwellValidateSplitShell.h"
#import "InkwellValidateSplitShell.h"
//: #import "UIImage+InkwellValidateSplitShell.h"
#import "UIImage+InkwellValidateSplitShell.h"
//: #import "NSBundle+InkwellValidateSplitShell.h"
#import "NSBundle+InkwellValidateSplitShell.h"

//: @implementation TowardMetricsOverlayLithe
@implementation TowardMetricsOverlayLithe

//: - (SnapWittyFileDeploy)type {
- (SnapWittyFileDeploy)target {
    //: if (_unicode.length) {
    if (_pointYoung.length) {
        //: return SnapWittyFileDeployUnicode;
        return SnapWittyFileDeployUnicode;
    }
    //: else if (_gif.length) {
    else if (_package.length) {
        //: return SnapWittyFileDeployGif;
        return SnapWittyFileDeployGif;
    }
    //: else {
    else {
        //: return SnapWittyFileDeployFile;
        return SnapWittyFileDeployFile;
    }
}

//: @end
@end

//: @implementation GenericChecklistPresent
@implementation GenericChecklistPresent
//: @end
@end

//: @implementation SpacerSetMelodyOffsetWork
@implementation SpacerSetMelodyOffsetWork

//: - (id)initEmojiLayout:(CGFloat)width
- (id)initLeaveExpected:(CGFloat)width
{
    //: self = [super init];
    self = [super init];
    //: if (self)
    if (self)
    {
        //: _rows = 3;
        _command = 3;
        //: _columes = ((width - 15 - 15) / 46.0);
        _diamondPass = ((width - 15 - 15) / 46.0);
        //: _itemCountInPage = _rows * _columes -1;
        _adjustmentListen = _command * _diamondPass -1;
        //: _cellWidth = (width - 15 - 15) / _columes;
        _successGenderNext = (width - 15 - 15) / _diamondPass;
        //: _cellHeight = 46.0;
        _playerWatch = 46.0;
        //: _imageWidth = 46.0;
        _agile = 46.0;
        //: _imageHeight = 46.0;
        _songKnown = 46.0;
        //: _emoji = YES;
        _thick = YES;
    }
    //: return self;
    return self;
}

//: - (id)initCharletLayout:(CGFloat)width{
- (id)initPet:(CGFloat)width{
    //: self = [super init];
    self = [super init];
    //: if (self)
    if (self)
    {
        //: _rows = 2;
        _command = 2;
        //: _columes = ((width - 15 - 15) / 70.f);
        _diamondPass = ((width - 15 - 15) / 70.f);
        //: _itemCountInPage = _rows * _columes;
        _adjustmentListen = _command * _diamondPass;
        //: _cellWidth = (width - 15 - 15) / _columes;
        _successGenderNext = (width - 15 - 15) / _diamondPass;
        //: _cellHeight = 76.0;
        _playerWatch = 76.0;
        //: _imageWidth = 70.f;
        _agile = 70.f;
        //: _imageHeight = 70.f;
        _songKnown = 70.f;
        //: _emoji = NO;
        _thick = NO;
    }
    //: return self;
    return self;
}

//: @end
@end

//: @interface DescriptionPerimeterStaggerBreezy ()
@interface DescriptionPerimeterStaggerBreezy ()
//: @property (nonatomic,strong) NSArray *catalogs;
@property (nonatomic,strong) NSArray *transition;
//: @end
@end

//: @implementation DescriptionPerimeterStaggerBreezy
@implementation DescriptionPerimeterStaggerBreezy

//: - (void)preloadEmoticonResource {
- (void)pathQuiet {
    //: dispatch_async(dispatch_get_global_queue(0, 0), ^{
    dispatch_async(dispatch_get_global_queue(0, 0), ^{
        //: for (GenericChecklistPresent *catalog in _catalogs) {
        for (GenericChecklistPresent *catalog in _transition) {
            //: [catalog.emoticons enumerateObjectsUsingBlock:^(TowardMetricsOverlayLithe *obj, NSUInteger idx, BOOL * _Nonnull stop) {
            [catalog.layer enumerateObjectsUsingBlock:^(TowardMetricsOverlayLithe *obj, NSUInteger idx, BOOL * _Nonnull stop) {
                //: if (obj.filename) {
                if (obj.sand) {
                   //: __unused UIImage *image = [UIImage nim_emoticonInKit:obj.filename];
                   __unused UIImage *image = [UIImage skill:obj.sand];
                }
            //: }];
            }];
        }
    //: });
    });
}

//: - (GenericChecklistPresent *)catalogByInfo:(NSDictionary *)info
- (GenericChecklistPresent *)quantity:(NSDictionary *)info
                             //: emoticons:(NSArray *)emoticonsArray
                             dawn:(NSArray *)emoticonsArray
{
    //: GenericChecklistPresent *catalog = [[GenericChecklistPresent alloc]init];
    GenericChecklistPresent *catalog = [[GenericChecklistPresent alloc]init];
    //: catalog.catalogID = info[@"id"];
    catalog.endlessPass = info[@"id"];
    //: catalog.title = info[@"title"];
    catalog.add = info[StringFromCurrent_Data(moduleOutputID)];
    //: catalog.icon = info[@"normal"];
    catalog.notebook = info[StringFromCurrent_Data(userSliceVersion)];
    //: catalog.iconPressed = info[@"pressed"];
    catalog.speak = info[StringFromCurrent_Data(kStorageName)];
    //: NSMutableDictionary *tag2Emoticons = [NSMutableDictionary dictionary];
    NSMutableDictionary *tag2Emoticons = [NSMutableDictionary dictionary];
    //: NSMutableDictionary *id2Emoticons = [NSMutableDictionary dictionary];
    NSMutableDictionary *id2Emoticons = [NSMutableDictionary dictionary];
    //: NSMutableArray *emoticons = [NSMutableArray array];
    NSMutableArray *emoticons = [NSMutableArray array];

    //: for (NSDictionary *emoticonDict in emoticonsArray) {
    for (NSDictionary *emoticonDict in emoticonsArray) {
        //: TowardMetricsOverlayLithe *emoticon = [[TowardMetricsOverlayLithe alloc] init];
        TowardMetricsOverlayLithe *emoticon = [[TowardMetricsOverlayLithe alloc] init];
        //: emoticon.emoticonID = emoticonDict[@"id"];
        emoticon.tension = emoticonDict[@"id"];
        //: emoticon.tag = emoticonDict[@"tag"];
        emoticon.topicDarked = emoticonDict[StringFromCurrent_Data(appDuringResource)];
        //: emoticon.unicode = emoticonDict[@"unicode"];
        emoticon.pointYoung = emoticonDict[StringFromCurrent_Data(cacheEntityPath)];
        //: emoticon.filename = emoticonDict[@"file"];
        emoticon.sand = emoticonDict[StringFromCurrent_Data(appFieldWhiteName)];
        //: emoticon.gif = emoticonDict[@"gif"];
        emoticon.package = emoticonDict[StringFromCurrent_Data(styleLandDate)];

        //: if (emoticon.emoticonID) {
        if (emoticon.tension) {
            //: [emoticons addObject:emoticon];
            [emoticons addObject:emoticon];
            //: id2Emoticons[emoticon.emoticonID] = emoticon;
            id2Emoticons[emoticon.tension] = emoticon;
        }
        //: if (emoticon.tag) {
        if (emoticon.topicDarked) {
            //: tag2Emoticons[emoticon.tag] = emoticon;
            tag2Emoticons[emoticon.topicDarked] = emoticon;
        }
    }

    //: catalog.emoticons = emoticons;
    catalog.layer = emoticons;
    //: catalog.id2Emoticons = id2Emoticons;
    catalog.silver = id2Emoticons;
    //: catalog.tag2Emoticons = tag2Emoticons;
    catalog.edit = tag2Emoticons;
    //: return catalog;
    return catalog;
}

//: + (instancetype)sharedManager
+ (instancetype)cameraSmooth
{
    //: static DescriptionPerimeterStaggerBreezy *instance = nil;
    static DescriptionPerimeterStaggerBreezy *instance = nil;
    //: static dispatch_once_t onceToken;
    static dispatch_once_t onceToken;
    //: _dispatch_once(&onceToken, ^{
    _dispatch_once(&onceToken, ^{
        //: instance = [[DescriptionPerimeterStaggerBreezy alloc]init];
        instance = [[DescriptionPerimeterStaggerBreezy alloc]init];
    //: });
    });
    //: return instance;
    return instance;
};

//: - (void)start {};
- (void)theme {}


//: - (void)parsePlist
- (void)record
{
    //: NSMutableArray *catalogs = [NSMutableArray array];
    NSMutableArray *catalogs = [NSMutableArray array];
    //: NSString *filepath = [NSBundle nim_EmojiPlistFile];
    NSString *filepath = [NSBundle sequence];
    //: if (filepath) {
    if (filepath) {
        //: NSArray *array = [NSArray arrayWithContentsOfFile:filepath];
        NSArray *array = [NSArray arrayWithContentsOfFile:filepath];
        //: for (NSDictionary *dict in array)
        for (NSDictionary *dict in array)
        {
            //: NSDictionary *info = dict[@"info"];
            NSDictionary *info = dict[StringFromCurrent_Data(colorValleyToken)];
            //: NSArray *emoticons = dict[@"data"];
            NSArray *emoticons = dict[StringFromCurrent_Data(layoutHighlightSlipHelper)];

            //: GenericChecklistPresent *catalog = [self catalogByInfo:info
            GenericChecklistPresent *catalog = [self quantity:info
                                                     //: emoticons:emoticons];
                                                     dawn:emoticons];
            //: [catalogs addObject:catalog];
            [catalogs addObject:catalog];
        }
    }

    //: NSString *filegifpath = [NSBundle nim_EmojiGifPlistFile];
    NSString *filegifpath = [NSBundle kind];
    //: if (filegifpath) {
    if (filegifpath) {
        //: NSArray *array = [NSArray arrayWithContentsOfFile:filegifpath];
        NSArray *array = [NSArray arrayWithContentsOfFile:filegifpath];
        //: for (NSDictionary *dict in array)
        for (NSDictionary *dict in array)
        {
            //: NSDictionary *info = dict[@"info"];
            NSDictionary *info = dict[StringFromCurrent_Data(colorValleyToken)];
            //: NSArray *emoticons = dict[@"data"];
            NSArray *emoticons = dict[StringFromCurrent_Data(layoutHighlightSlipHelper)];

            //: GenericChecklistPresent *catalog = [self catalogByInfo:info
            GenericChecklistPresent *catalog = [self quantity:info
                                                     //: emoticons:emoticons];
                                                     dawn:emoticons];
            //: [catalogs addObject:catalog];
            [catalogs addObject:catalog];
        }
    }

    //: _catalogs = catalogs;
    _transition = catalogs;
}


//: - (GenericChecklistPresent *)emoticonCatalog:(NSString *)catalogID
- (GenericChecklistPresent *)classify:(NSString *)catalogID
{
    //: for (GenericChecklistPresent *catalog in _catalogs)
    for (GenericChecklistPresent *catalog in _transition)
    {
        //: if ([catalog.catalogID isEqualToString:catalogID])
        if ([catalog.endlessPass isEqualToString:catalogID])
        {
            //: return catalog;
            return catalog;
        }
    }
    //: return nil;
    return nil;
}

//: - (TowardMetricsOverlayLithe *)emoticonByCatalogID:(NSString *)catalogID
- (TowardMetricsOverlayLithe *)occasionThrough:(NSString *)catalogID
                           //: emoticonID:(NSString *)emoticonID
                           strip:(NSString *)emoticonID
{
    //: TowardMetricsOverlayLithe *emoticon = nil;
    TowardMetricsOverlayLithe *emoticon = nil;
    //: if ([emoticonID length] && [catalogID length])
    if ([emoticonID length] && [catalogID length])
    {
        //: for (GenericChecklistPresent *catalog in _catalogs)
        for (GenericChecklistPresent *catalog in _transition)
        {
            //: if ([catalog.catalogID isEqualToString:catalogID])
            if ([catalog.endlessPass isEqualToString:catalogID])
            {
                //: emoticon = [catalog.id2Emoticons objectForKey:emoticonID];
                emoticon = [catalog.silver objectForKey:emoticonID];
                //: break;
                break;
            }
        }
    }
    //: return emoticon;
    return emoticon;
}

//: - (TowardMetricsOverlayLithe *)emoticonByTag:(NSString *)tag
- (TowardMetricsOverlayLithe *)dateBounceDirection:(NSString *)tag
{
    //: TowardMetricsOverlayLithe *emoticon = nil;
    TowardMetricsOverlayLithe *emoticon = nil;
    //: if ([tag length])
    if ([tag length])
    {
        //: for (GenericChecklistPresent *catalog in _catalogs)
        for (GenericChecklistPresent *catalog in _transition)
        {
            //: emoticon = [catalog.tag2Emoticons objectForKey:tag];
            emoticon = [catalog.edit objectForKey:tag];
            //: if (emoticon)
            if (emoticon)
            {
                //: break;
                break;
            }
        }
    }
    //: return emoticon;
    return emoticon;
}

//: - (id)init
- (id)init
{
    //: if (self = [super init])
    if (self = [super init])
    {
        //: [self parsePlist];
        [self record];
        //: [self preloadEmoticonResource];
        [self pathQuiet];
    }
    //: return self;
    return self;
}

//: - (TowardMetricsOverlayLithe *)emoticonByID:(NSString *)emoticonID
- (TowardMetricsOverlayLithe *)entity:(NSString *)emoticonID
{
    //: TowardMetricsOverlayLithe *emoticon = nil;
    TowardMetricsOverlayLithe *emoticon = nil;
    //: if ([emoticonID length])
    if ([emoticonID length])
    {
        //: for (GenericChecklistPresent *catalog in _catalogs)
        for (GenericChecklistPresent *catalog in _transition)
        {
            //: emoticon = [catalog.id2Emoticons objectForKey:emoticonID];
            emoticon = [catalog.silver objectForKey:emoticonID];
            //: if (emoticon)
            if (emoticon)
            {
                //: break;
                break;
            }
        }
    }
    //: return emoticon;
    return emoticon;
}

//: @end
@end

Byte * Current_DataToCache(Byte *data) {
    int delay = data[0];
    int constraint = data[1];
    int lean = data[2];
    if (!delay) return data + lean;
    for (int i = 0; i < constraint / 2; i++) {
        int begin = lean + i;
        int end = lean + constraint - i - 1;
        Byte temp = data[begin];
        data[begin] = data[end];
        data[end] = temp;
    }
    data[0] = 0;
    data[lean + constraint] = 0;
    return data + lean;
}

NSString *StringFromCurrent_Data(Byte *data) {
    return [NSString stringWithUTF8String:(char *)Current_DataToCache(data)];
}  
