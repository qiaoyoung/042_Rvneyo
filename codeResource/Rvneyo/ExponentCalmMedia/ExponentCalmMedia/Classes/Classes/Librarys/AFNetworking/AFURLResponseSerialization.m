
#import <Foundation/Foundation.h>

typedef struct {
    Byte skillInspect;
    Byte *sceneOriginal;
    unsigned int refresh;
	int recordAlongside;
	int projection;
} StructTransformData;

@interface TransformData : NSObject

+ (instancetype)sharedInstance;

//: image/x-xbitmap
@property (nonatomic, copy) NSString *viewSheetPath;

//: image/png
@property (nonatomic, copy) NSString *layoutTurnDriverName;

//: image/gif
@property (nonatomic, copy) NSString *layoutHandsomeRecoverKey;

//: application/x-plist
@property (nonatomic, copy) NSString *globalMonsterMagicCreateerNumber;

//: Request failed: unacceptable content-type: %@
@property (nonatomic, copy) NSString *moduleSunRecordPreference;

//: application/xml
@property (nonatomic, copy) NSString *styleWealthyTimer;

//: Request failed: %@ (%ld)
@property (nonatomic, copy) NSString *globalEpisodeEvent;

//: image/jpeg
@property (nonatomic, copy) NSString *styleIdentifyConfig;

//: image/bmp
@property (nonatomic, copy) NSString *userLockResult;

//: text/javascript
@property (nonatomic, copy) NSString *k_worthBuildMessage;

//: application/json
@property (nonatomic, copy) NSString *widgetCableResource;

//: com.alamofire.error.serialization.response
@property (nonatomic, copy) NSString *colorSensorName;

//: image/x-bmp
@property (nonatomic, copy) NSString *appFeatureDriverEvent;

//: com.alamofire.serialization.response.error.response
@property (nonatomic, copy) NSString *screenDeliverGravityID;

//: com.alamofire.serialization.response.error.data
@property (nonatomic, copy) NSString *styleImprovedToken;

//: text/json
@property (nonatomic, copy) NSString *kTrainConfig;

//: text/xml
@property (nonatomic, copy) NSString *layoutImprovedDistinctivePreference;

//: image/x-win-bitmap
@property (nonatomic, copy) NSString *componentConnectTime;

//: image/tiff
@property (nonatomic, copy) NSString *networkCivicVersion;

//: image/ico
@property (nonatomic, copy) NSString *colorBarPreference;

//: image/x-icon
@property (nonatomic, copy) NSString *k_documentHelper;

//: AFNetworking
@property (nonatomic, copy) NSString *viewPlotTitle;

@end

@implementation TransformData

//: text/json
- (NSString *)kTrainConfig {
    if (!_kTrainConfig) {
		NSArray<NSString *> *origin = @[@"77", @"92", @"65", @"77", @"22", @"83", @"74", @"86", @"87", @"116"];
		NSData *data = [TransformData TransformDataToData:origin];
        StructTransformData value = (StructTransformData){57, (Byte *)data.bytes, 9, 109, 139};
        _kTrainConfig = [self StringFromTransformData:&value];
    }
    return _kTrainConfig;
}

//: application/json
- (NSString *)widgetCableResource {
    if (!_widgetCableResource) {
		NSArray<NSString *> *origin = @[@"184", @"169", @"169", @"181", @"176", @"186", @"184", @"173", @"176", @"182", @"183", @"246", @"179", @"170", @"182", @"183", @"217"];
		NSData *data = [TransformData TransformDataToData:origin];
        StructTransformData value = (StructTransformData){217, (Byte *)data.bytes, 16, 73, 135};
        _widgetCableResource = [self StringFromTransformData:&value];
    }
    return _widgetCableResource;
}

//: Request failed: %@ (%ld)
- (NSString *)globalEpisodeEvent {
    if (!_globalEpisodeEvent) {
		NSArray<NSString *> *origin = @[@"243", @"196", @"208", @"212", @"196", @"210", @"213", @"129", @"199", @"192", @"200", @"205", @"196", @"197", @"155", @"129", @"132", @"225", @"129", @"137", @"132", @"205", @"197", @"136", @"247"];
		NSData *data = [TransformData TransformDataToData:origin];
        StructTransformData value = (StructTransformData){161, (Byte *)data.bytes, 24, 163, 210};
        _globalEpisodeEvent = [self StringFromTransformData:&value];
    }
    return _globalEpisodeEvent;
}

//: image/x-win-bitmap
- (NSString *)componentConnectTime {
    if (!_componentConnectTime) {
		NSArray<NSString *> *origin = @[@"62", @"58", @"54", @"48", @"50", @"120", @"47", @"122", @"32", @"62", @"57", @"122", @"53", @"62", @"35", @"58", @"54", @"39", @"107"];
		NSData *data = [TransformData TransformDataToData:origin];
        StructTransformData value = (StructTransformData){87, (Byte *)data.bytes, 18, 148, 105};
        _componentConnectTime = [self StringFromTransformData:&value];
    }
    return _componentConnectTime;
}

//: application/x-plist
- (NSString *)globalMonsterMagicCreateerNumber {
    if (!_globalMonsterMagicCreateerNumber) {
		NSArray<NSString *> *origin = @[@"227", @"242", @"242", @"238", @"235", @"225", @"227", @"246", @"235", @"237", @"236", @"173", @"250", @"175", @"242", @"238", @"235", @"241", @"246", @"229"];
		NSData *data = [TransformData TransformDataToData:origin];
        StructTransformData value = (StructTransformData){130, (Byte *)data.bytes, 19, 16, 177};
        _globalMonsterMagicCreateerNumber = [self StringFromTransformData:&value];
    }
    return _globalMonsterMagicCreateerNumber;
}

//: image/x-bmp
- (NSString *)appFeatureDriverEvent {
    if (!_appFeatureDriverEvent) {
		NSArray<NSString *> *origin = @[@"75", @"79", @"67", @"69", @"71", @"13", @"90", @"15", @"64", @"79", @"82", @"79"];
		NSData *data = [TransformData TransformDataToData:origin];
        StructTransformData value = (StructTransformData){34, (Byte *)data.bytes, 11, 79, 9};
        _appFeatureDriverEvent = [self StringFromTransformData:&value];
    }
    return _appFeatureDriverEvent;
}

//: image/bmp
- (NSString *)userLockResult {
    if (!_userLockResult) {
		NSArray<NSString *> *origin = @[@"12", @"8", @"4", @"2", @"0", @"74", @"7", @"8", @"21", @"36"];
		NSData *data = [TransformData TransformDataToData:origin];
        StructTransformData value = (StructTransformData){101, (Byte *)data.bytes, 9, 135, 151};
        _userLockResult = [self StringFromTransformData:&value];
    }
    return _userLockResult;
}

//: text/xml
- (NSString *)layoutImprovedDistinctivePreference {
    if (!_layoutImprovedDistinctivePreference) {
		NSArray<NSString *> *origin = @[@"6", @"23", @"10", @"6", @"93", @"10", @"31", @"30", @"67"];
		NSData *data = [TransformData TransformDataToData:origin];
        StructTransformData value = (StructTransformData){114, (Byte *)data.bytes, 8, 5, 145};
        _layoutImprovedDistinctivePreference = [self StringFromTransformData:&value];
    }
    return _layoutImprovedDistinctivePreference;
}

//: image/ico
- (NSString *)colorBarPreference {
    if (!_colorBarPreference) {
		NSArray<NSString *> *origin = @[@"191", @"187", @"183", @"177", @"179", @"249", @"191", @"181", @"185", @"237"];
		NSData *data = [TransformData TransformDataToData:origin];
        StructTransformData value = (StructTransformData){214, (Byte *)data.bytes, 9, 222, 178};
        _colorBarPreference = [self StringFromTransformData:&value];
    }
    return _colorBarPreference;
}

//: image/png
- (NSString *)layoutTurnDriverName {
    if (!_layoutTurnDriverName) {
		NSArray<NSString *> *origin = @[@"9", @"13", @"1", @"7", @"5", @"79", @"16", @"14", @"7", @"4"];
		NSData *data = [TransformData TransformDataToData:origin];
        StructTransformData value = (StructTransformData){96, (Byte *)data.bytes, 9, 113, 35};
        _layoutTurnDriverName = [self StringFromTransformData:&value];
    }
    return _layoutTurnDriverName;
}

//: Request failed: unacceptable content-type: %@
- (NSString *)moduleSunRecordPreference {
    if (!_moduleSunRecordPreference) {
		NSArray<NSString *> *origin = @[@"45", @"26", @"14", @"10", @"26", @"12", @"11", @"95", @"25", @"30", @"22", @"19", @"26", @"27", @"69", @"95", @"10", @"17", @"30", @"28", @"28", @"26", @"15", @"11", @"30", @"29", @"19", @"26", @"95", @"28", @"16", @"17", @"11", @"26", @"17", @"11", @"82", @"11", @"6", @"15", @"26", @"69", @"95", @"90", @"63", @"244"];
		NSData *data = [TransformData TransformDataToData:origin];
        StructTransformData value = (StructTransformData){127, (Byte *)data.bytes, 45, 54, 232};
        _moduleSunRecordPreference = [self StringFromTransformData:&value];
    }
    return _moduleSunRecordPreference;
}

//: com.alamofire.serialization.response.error.response
- (NSString *)screenDeliverGravityID {
    if (!_screenDeliverGravityID) {
		NSArray<NSString *> *origin = @[@"199", @"203", @"201", @"138", @"197", @"200", @"197", @"201", @"203", @"194", @"205", @"214", @"193", @"138", @"215", @"193", @"214", @"205", @"197", @"200", @"205", @"222", @"197", @"208", @"205", @"203", @"202", @"138", @"214", @"193", @"215", @"212", @"203", @"202", @"215", @"193", @"138", @"193", @"214", @"214", @"203", @"214", @"138", @"214", @"193", @"215", @"212", @"203", @"202", @"215", @"193", @"149"];
		NSData *data = [TransformData TransformDataToData:origin];
        StructTransformData value = (StructTransformData){164, (Byte *)data.bytes, 51, 151, 107};
        _screenDeliverGravityID = [self StringFromTransformData:&value];
    }
    return _screenDeliverGravityID;
}

//: image/gif
- (NSString *)layoutHandsomeRecoverKey {
    if (!_layoutHandsomeRecoverKey) {
		NSArray<NSString *> *origin = @[@"83", @"87", @"91", @"93", @"95", @"21", @"93", @"83", @"92", @"224"];
		NSData *data = [TransformData TransformDataToData:origin];
        StructTransformData value = (StructTransformData){58, (Byte *)data.bytes, 9, 107, 141};
        _layoutHandsomeRecoverKey = [self StringFromTransformData:&value];
    }
    return _layoutHandsomeRecoverKey;
}

//: application/xml
- (NSString *)styleWealthyTimer {
    if (!_styleWealthyTimer) {
		NSArray<NSString *> *origin = @[@"87", @"70", @"70", @"90", @"95", @"85", @"87", @"66", @"95", @"89", @"88", @"25", @"78", @"91", @"90", @"217"];
		NSData *data = [TransformData TransformDataToData:origin];
        StructTransformData value = (StructTransformData){54, (Byte *)data.bytes, 15, 209, 114};
        _styleWealthyTimer = [self StringFromTransformData:&value];
    }
    return _styleWealthyTimer;
}

- (Byte *)TransformDataToByte:(StructTransformData *)data {
    for (int i = 0; i < data->refresh; i++) {
        data->sceneOriginal[i] ^= data->skillInspect;
    }
    data->sceneOriginal[data->refresh] = 0;
	if (data->refresh >= 2) {
		data->recordAlongside = data->sceneOriginal[0];
		data->projection = data->sceneOriginal[1];
	}
    return data->sceneOriginal;
}

//: com.alamofire.serialization.response.error.data
- (NSString *)styleImprovedToken {
    if (!_styleImprovedToken) {
		NSArray<NSString *> *origin = @[@"213", @"217", @"219", @"152", @"215", @"218", @"215", @"219", @"217", @"208", @"223", @"196", @"211", @"152", @"197", @"211", @"196", @"223", @"215", @"218", @"223", @"204", @"215", @"194", @"223", @"217", @"216", @"152", @"196", @"211", @"197", @"198", @"217", @"216", @"197", @"211", @"152", @"211", @"196", @"196", @"217", @"196", @"152", @"210", @"215", @"194", @"215", @"7"];
		NSData *data = [TransformData TransformDataToData:origin];
        StructTransformData value = (StructTransformData){182, (Byte *)data.bytes, 47, 18, 144};
        _styleImprovedToken = [self StringFromTransformData:&value];
    }
    return _styleImprovedToken;
}

//: image/tiff
- (NSString *)networkCivicVersion {
    if (!_networkCivicVersion) {
		NSArray<NSString *> *origin = @[@"229", @"225", @"237", @"235", @"233", @"163", @"248", @"229", @"234", @"234", @"107"];
		NSData *data = [TransformData TransformDataToData:origin];
        StructTransformData value = (StructTransformData){140, (Byte *)data.bytes, 10, 156, 84};
        _networkCivicVersion = [self StringFromTransformData:&value];
    }
    return _networkCivicVersion;
}

//: image/jpeg
- (NSString *)styleIdentifyConfig {
    if (!_styleIdentifyConfig) {
		NSArray<NSString *> *origin = @[@"102", @"98", @"110", @"104", @"106", @"32", @"101", @"127", @"106", @"104", @"130"];
		NSData *data = [TransformData TransformDataToData:origin];
        StructTransformData value = (StructTransformData){15, (Byte *)data.bytes, 10, 182, 53};
        _styleIdentifyConfig = [self StringFromTransformData:&value];
    }
    return _styleIdentifyConfig;
}

//: text/javascript
- (NSString *)k_worthBuildMessage {
    if (!_k_worthBuildMessage) {
		NSArray<NSString *> *origin = @[@"39", @"54", @"43", @"39", @"124", @"57", @"50", @"37", @"50", @"32", @"48", @"33", @"58", @"35", @"39", @"83"];
		NSData *data = [TransformData TransformDataToData:origin];
        StructTransformData value = (StructTransformData){83, (Byte *)data.bytes, 15, 168, 203};
        _k_worthBuildMessage = [self StringFromTransformData:&value];
    }
    return _k_worthBuildMessage;
}

//: image/x-icon
- (NSString *)k_documentHelper {
    if (!_k_documentHelper) {
		NSArray<NSString *> *origin = @[@"22", @"18", @"30", @"24", @"26", @"80", @"7", @"82", @"22", @"28", @"16", @"17", @"41"];
		NSData *data = [TransformData TransformDataToData:origin];
        StructTransformData value = (StructTransformData){127, (Byte *)data.bytes, 12, 12, 228};
        _k_documentHelper = [self StringFromTransformData:&value];
    }
    return _k_documentHelper;
}

- (NSString *)StringFromTransformData:(StructTransformData *)data {
    return [NSString stringWithUTF8String:(char *)[self TransformDataToByte:data]];
}

+ (NSData *)TransformDataToData:(NSArray<NSString *> *)value {
    NSMutableArray<NSString *> *array = [NSMutableArray arrayWithArray:value];
    NSInteger length = array.count;
    Byte *buffer = (Byte *)malloc(length + 1);
    for (int i = 0; i < length; i++) {
        buffer[i] = [array[i] intValue];
    }
    buffer[length] = 0;
    return [NSData dataWithBytesNoCopy:buffer length:length freeWhenDone:YES];
}

+ (instancetype)sharedInstance {
    static TransformData *instance = nil;
    static dispatch_once_t onceToken;
    dispatch_once(&onceToken, ^{
        instance = [[self alloc] init];
    });
    return instance;
}

//: com.alamofire.error.serialization.response
- (NSString *)colorSensorName {
    if (!_colorSensorName) {
		NSArray<NSString *> *origin = @[@"202", @"198", @"196", @"135", @"200", @"197", @"200", @"196", @"198", @"207", @"192", @"219", @"204", @"135", @"204", @"219", @"219", @"198", @"219", @"135", @"218", @"204", @"219", @"192", @"200", @"197", @"192", @"211", @"200", @"221", @"192", @"198", @"199", @"135", @"219", @"204", @"218", @"217", @"198", @"199", @"218", @"204", @"30"];
		NSData *data = [TransformData TransformDataToData:origin];
        StructTransformData value = (StructTransformData){169, (Byte *)data.bytes, 42, 101, 60};
        _colorSensorName = [self StringFromTransformData:&value];
    }
    return _colorSensorName;
}

//: AFNetworking
- (NSString *)viewPlotTitle {
    if (!_viewPlotTitle) {
		NSArray<NSString *> *origin = @[@"120", @"127", @"119", @"92", @"77", @"78", @"86", @"75", @"82", @"80", @"87", @"94", @"168"];
		NSData *data = [TransformData TransformDataToData:origin];
        StructTransformData value = (StructTransformData){57, (Byte *)data.bytes, 12, 88, 204};
        _viewPlotTitle = [self StringFromTransformData:&value];
    }
    return _viewPlotTitle;
}

//: image/x-xbitmap
- (NSString *)viewSheetPath {
    if (!_viewSheetPath) {
		NSArray<NSString *> *origin = @[@"113", @"117", @"121", @"127", @"125", @"55", @"96", @"53", @"96", @"122", @"113", @"108", @"117", @"121", @"104", @"191"];
		NSData *data = [TransformData TransformDataToData:origin];
        StructTransformData value = (StructTransformData){24, (Byte *)data.bytes, 15, 136, 74};
        _viewSheetPath = [self StringFromTransformData:&value];
    }
    return _viewSheetPath;
}

@end

// __DEBUG__
// __CLOSE_PRINT__
// AFURLResponseSerialization.m
// Copyright (c) 2011â€“2016 Alamofire Software Foundation ( http://alamofire.org/ )
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

// __M_A_C_R_O__
//: #import "AFURLResponseSerialization.h"
#import "AFURLResponseSerialization.h"
//: #import <TargetConditionals.h>
#import <TargetConditionals.h>
//: #import <UIKit/UIKit.h>
#import <UIKit/UIKit.h>
//: #import <CoreGraphics/CoreGraphics.h>
#import <CoreGraphics/CoreGraphics.h>
//: #import <UIKit/UIKit.h>
#import <UIKit/UIKit.h>

//: NSString * const AFURLResponseSerializationErrorDomain = @"com.alamofire.error.serialization.response";

NSString * const globalCleanKey (NSString *value) {
    if (value) {
        return [value.uppercaseString stringByAppendingString:@"of"];
    }
    return  [TransformData sharedInstance].colorSensorName;
};
//: NSString * const AFNetworkingOperationFailingURLResponseErrorKey = @"com.alamofire.serialization.response.error.response";

NSString * const screenRecordValue (NSString *value) {
    if (value) {
        return [value.lowercaseString stringByAppendingString:@"accessible"];
    }
    return  [TransformData sharedInstance].screenDeliverGravityID;
};
//: NSString * const AFNetworkingOperationFailingURLResponseDataErrorKey = @"com.alamofire.serialization.response.error.data";

NSString * const colorWealthTime (NSString *value) {
    if (value) {
        return [value.capitalizedString stringByAppendingString:@"regular"];
    }
    return  [TransformData sharedInstance].styleImprovedToken;
};

//: static NSError * AFErrorWithUnderlyingError(NSError *error, NSError *underlyingError) {
static NSError * translatePlayer(NSError *error, NSError *underlyingError) {
    //: if (!error) {
    if (!error) {
        //: return underlyingError;
        return underlyingError;
    }

    //: if (!underlyingError || error.userInfo[NSUnderlyingErrorKey]) {
    if (!underlyingError || error.userInfo[NSUnderlyingErrorKey]) {
        //: return error;
        return error;
    }

    //: NSMutableDictionary *mutableUserInfo = [error.userInfo mutableCopy];
    NSMutableDictionary *mutableUserInfo = [error.userInfo mutableCopy];
    //: mutableUserInfo[NSUnderlyingErrorKey] = underlyingError;
    mutableUserInfo[NSUnderlyingErrorKey] = underlyingError;

    //: return [[NSError alloc] initWithDomain:error.domain code:error.code userInfo:mutableUserInfo];
    return [[NSError alloc] initWithDomain:error.domain code:error.code userInfo:mutableUserInfo];
}

//: static BOOL AFErrorOrUnderlyingErrorHasCodeInDomain(NSError *error, NSInteger code, NSString *domain) {
static BOOL robotVideo(NSError *error, NSInteger code, NSString *domain) {
    //: if ([error.domain isEqualToString:domain] && error.code == code) {
    if ([error.domain isEqualToString:domain] && error.code == code) {
        //: return YES;
        return YES;
    //: } else if (error.userInfo[NSUnderlyingErrorKey]) {
    } else if (error.userInfo[NSUnderlyingErrorKey]) {
        //: return AFErrorOrUnderlyingErrorHasCodeInDomain(error.userInfo[NSUnderlyingErrorKey], code, domain);
        return robotVideo(error.userInfo[NSUnderlyingErrorKey], code, domain);
    }

    //: return NO;
    return NO;
}

//: id AFJSONObjectByRemovingKeysWithNullValues(id JSONObject, NSJSONReadingOptions readingOptions) {
id quantityeractionOperate(id JSONObject, NSJSONReadingOptions readingOptions) {
    //: if ([JSONObject isKindOfClass:[NSArray class]]) {
    if ([JSONObject isKindOfClass:[NSArray class]]) {
        //: NSMutableArray *mutableArray = [NSMutableArray arrayWithCapacity:[(NSArray *)JSONObject count]];
        NSMutableArray *mutableArray = [NSMutableArray arrayWithCapacity:[(NSArray *)JSONObject count]];
        //: for (id value in (NSArray *)JSONObject) {
        for (id value in (NSArray *)JSONObject) {
            //: if (![value isEqual:[NSNull null]]) {
            if (![value isEqual:[NSNull null]]) {
                //: [mutableArray addObject:AFJSONObjectByRemovingKeysWithNullValues(value, readingOptions)];
                [mutableArray addObject:quantityeractionOperate(value, readingOptions)];
            }
        }

        //: return (readingOptions & NSJSONReadingMutableContainers) ? mutableArray : [NSArray arrayWithArray:mutableArray];
        return (readingOptions & NSJSONReadingMutableContainers) ? mutableArray : [NSArray arrayWithArray:mutableArray];
    //: } else if ([JSONObject isKindOfClass:[NSDictionary class]]) {
    } else if ([JSONObject isKindOfClass:[NSDictionary class]]) {
        //: NSMutableDictionary *mutableDictionary = [NSMutableDictionary dictionaryWithDictionary:JSONObject];
        NSMutableDictionary *mutableDictionary = [NSMutableDictionary dictionaryWithDictionary:JSONObject];
        //: for (id <NSCopying> key in [(NSDictionary *)JSONObject allKeys]) {
        for (id <NSCopying> key in [(NSDictionary *)JSONObject allKeys]) {
            //: id value = (NSDictionary *)JSONObject[key];
            id value = (NSDictionary *)JSONObject[key];
            //: if (!value || [value isEqual:[NSNull null]]) {
            if (!value || [value isEqual:[NSNull null]]) {
                //: [mutableDictionary removeObjectForKey:key];
                [mutableDictionary removeObjectForKey:key];
            //: } else if ([value isKindOfClass:[NSArray class]] || [value isKindOfClass:[NSDictionary class]]) {
            } else if ([value isKindOfClass:[NSArray class]] || [value isKindOfClass:[NSDictionary class]]) {
                //: mutableDictionary[key] = AFJSONObjectByRemovingKeysWithNullValues(value, readingOptions);
                mutableDictionary[key] = quantityeractionOperate(value, readingOptions);
            }
        }

        //: return (readingOptions & NSJSONReadingMutableContainers) ? mutableDictionary : [NSDictionary dictionaryWithDictionary:mutableDictionary];
        return (readingOptions & NSJSONReadingMutableContainers) ? mutableDictionary : [NSDictionary dictionaryWithDictionary:mutableDictionary];
    }

    //: return JSONObject;
    return JSONObject;
}

//: @implementation AFHTTPResponseSerializer
@implementation AFHTTPResponseSerializer

//: + (instancetype)serializer {
+ (instancetype)unit {
    //: return [[self alloc] init];
    return [[self alloc] init];
}

//: #pragma mark - NSCopying
#pragma mark - NSCopying

//: - (instancetype)copyWithZone:(NSZone *)zone {
- (instancetype)copyWithZone:(NSZone *)zone {
    //: AFHTTPResponseSerializer *serializer = [[[self class] allocWithZone:zone] init];
    AFHTTPResponseSerializer *serializer = [[[self class] allocWithZone:zone] init];
    //: serializer.acceptableStatusCodes = [self.acceptableStatusCodes copyWithZone:zone];
    serializer.saveerEndlessing = [self.saveerEndlessing copyWithZone:zone];
    //: serializer.acceptableContentTypes = [self.acceptableContentTypes copyWithZone:zone];
    serializer.identifyFirsting = [self.identifyFirsting copyWithZone:zone];

    //: return serializer;
    return serializer;
}

//: - (void)encodeWithCoder:(NSCoder *)coder {
- (void)encodeWithCoder:(NSCoder *)coder {
    //: [coder encodeObject:self.acceptableStatusCodes forKey:NSStringFromSelector(@selector(acceptableStatusCodes))];
    [coder encodeObject:self.saveerEndlessing forKey:NSStringFromSelector(@selector(saveerEndlessing))];
    //: [coder encodeObject:self.acceptableContentTypes forKey:NSStringFromSelector(@selector(acceptableContentTypes))];
    [coder encodeObject:self.identifyFirsting forKey:NSStringFromSelector(@selector(identifyFirsting))];
}

//: #pragma mark - AFURLResponseSerialization
#pragma mark - AFURLResponseSerialization

//: - (id)responseObjectForResponse:(NSURLResponse *)response
- (id)occasion:(NSURLResponse *)response
                           //: data:(NSData *)data
                           belowArenaRaw:(NSData *)data
                          //: error:(NSError *__autoreleasing *)error
                          footAround:(NSError *__autoreleasing *)error
{
    //: [self validateResponse:(NSHTTPURLResponse *)response data:data error:error];
    [self filter:(NSHTTPURLResponse *)response dry:data fresh:error];

    //: return data;
    return data;
}

//: - (instancetype)init {
- (instancetype)init {
    //: self = [super init];
    self = [super init];
    //: if (!self) {
    if (!self) {
        //: return nil;
        return nil;
    }

    //: self.acceptableStatusCodes = [NSIndexSet indexSetWithIndexesInRange:NSMakeRange(200, 100)];
    self.saveerEndlessing = [NSIndexSet indexSetWithIndexesInRange:NSMakeRange(200, 100)];
    //: self.acceptableContentTypes = nil;
    self.identifyFirsting = nil;

    //: return self;
    return self;
}

//: #pragma mark - NSSecureCoding
#pragma mark - NSSecureCoding

//: + (BOOL)supportsSecureCoding {
+ (BOOL)supportsSecureCoding {
    //: return YES;
    return YES;
}

//: #pragma mark -
#pragma mark -

//: - (BOOL)validateResponse:(NSHTTPURLResponse *)response
- (BOOL)filter:(NSHTTPURLResponse *)response
                    //: data:(NSData *)data
                    dry:(NSData *)data
                   //: error:(NSError * __autoreleasing *)error
                   fresh:(NSError * __autoreleasing *)error
{
    //: BOOL responseIsValid = YES;
    BOOL responseIsValid = YES;
    //: NSError *validationError = nil;
    NSError *validationError = nil;

    //: if ([response isKindOfClass:[NSHTTPURLResponse class]]) {
    if ([response isKindOfClass:[NSHTTPURLResponse class]]) {
        //: if (self.acceptableContentTypes && ![self.acceptableContentTypes containsObject:[response MIMEType]] &&
        if (self.identifyFirsting && ![self.identifyFirsting containsObject:[response MIMEType]] &&
            //: !([response MIMEType] == nil && [data length] == 0)) {
            !([response MIMEType] == nil && [data length] == 0)) {

            //: if ([data length] > 0 && [response URL]) {
            if ([data length] > 0 && [response URL]) {
                //: NSMutableDictionary *mutableUserInfo = [@{
                NSMutableDictionary *mutableUserInfo = [@{
                                                          //: NSLocalizedDescriptionKey: [NSString stringWithFormat:NSLocalizedStringFromTable(@"Request failed: unacceptable content-type: %@", @"AFNetworking", nil), [response MIMEType]],
                                                          NSLocalizedDescriptionKey: [NSString stringWithFormat:NSLocalizedStringFromTable([TransformData sharedInstance].moduleSunRecordPreference, [TransformData sharedInstance].viewPlotTitle, nil), [response MIMEType]],
                                                          //: NSURLErrorFailingURLErrorKey:[response URL],
                                                          NSURLErrorFailingURLErrorKey:[response URL],
                                                          //: AFNetworkingOperationFailingURLResponseErrorKey: response,
                                                          screenRecordValue(nil): response,
                                                        //: } mutableCopy];
                                                        } mutableCopy];
                //: if (data) {
                if (data) {
                    //: mutableUserInfo[AFNetworkingOperationFailingURLResponseDataErrorKey] = data;
                    mutableUserInfo[colorWealthTime(nil)] = data;
                }

                //: validationError = AFErrorWithUnderlyingError([NSError errorWithDomain:AFURLResponseSerializationErrorDomain code:NSURLErrorCannotDecodeContentData userInfo:mutableUserInfo], validationError);
                validationError = translatePlayer([NSError errorWithDomain:globalCleanKey(nil) code:NSURLErrorCannotDecodeContentData userInfo:mutableUserInfo], validationError);
            }

            //: responseIsValid = NO;
            responseIsValid = NO;
        }

        //: if (self.acceptableStatusCodes && ![self.acceptableStatusCodes containsIndex:(NSUInteger)response.statusCode] && [response URL]) {
        if (self.saveerEndlessing && ![self.saveerEndlessing containsIndex:(NSUInteger)response.statusCode] && [response URL]) {
            //: NSMutableDictionary *mutableUserInfo = [@{
            NSMutableDictionary *mutableUserInfo = [@{
                                               //: NSLocalizedDescriptionKey: [NSString stringWithFormat:NSLocalizedStringFromTable(@"Request failed: %@ (%ld)", @"AFNetworking", nil), [NSHTTPURLResponse localizedStringForStatusCode:response.statusCode], (long)response.statusCode],
                                               NSLocalizedDescriptionKey: [NSString stringWithFormat:NSLocalizedStringFromTable([TransformData sharedInstance].globalEpisodeEvent, [TransformData sharedInstance].viewPlotTitle, nil), [NSHTTPURLResponse localizedStringForStatusCode:response.statusCode], (long)response.statusCode],
                                               //: NSURLErrorFailingURLErrorKey:[response URL],
                                               NSURLErrorFailingURLErrorKey:[response URL],
                                               //: AFNetworkingOperationFailingURLResponseErrorKey: response,
                                               screenRecordValue(nil): response,
                                       //: } mutableCopy];
                                       } mutableCopy];

            //: if (data) {
            if (data) {
                //: mutableUserInfo[AFNetworkingOperationFailingURLResponseDataErrorKey] = data;
                mutableUserInfo[colorWealthTime(nil)] = data;
            }

            //: validationError = AFErrorWithUnderlyingError([NSError errorWithDomain:AFURLResponseSerializationErrorDomain code:NSURLErrorBadServerResponse userInfo:mutableUserInfo], validationError);
            validationError = translatePlayer([NSError errorWithDomain:globalCleanKey(nil) code:NSURLErrorBadServerResponse userInfo:mutableUserInfo], validationError);

            //: responseIsValid = NO;
            responseIsValid = NO;
        }
    }

    //: if (error && !responseIsValid) {
    if (error && !responseIsValid) {
        //: *error = validationError;
        *error = validationError;
    }

    //: return responseIsValid;
    return responseIsValid;
}

//: - (instancetype)initWithCoder:(NSCoder *)decoder {
- (instancetype)initWithCoder:(NSCoder *)decoder {
    //: self = [self init];
    self = [self init];
    //: if (!self) {
    if (!self) {
        //: return nil;
        return nil;
    }

    //: self.acceptableStatusCodes = [decoder decodeObjectOfClass:[NSIndexSet class] forKey:NSStringFromSelector(@selector(acceptableStatusCodes))];
    self.saveerEndlessing = [decoder decodeObjectOfClass:[NSIndexSet class] forKey:NSStringFromSelector(@selector(saveerEndlessing))];
    //: self.acceptableContentTypes = [decoder decodeObjectOfClass:[NSSet class] forKey:NSStringFromSelector(@selector(acceptableContentTypes))];
    self.identifyFirsting = [decoder decodeObjectOfClass:[NSSet class] forKey:NSStringFromSelector(@selector(identifyFirsting))];

    //: return self;
    return self;
}

//: @end
@end

//: #pragma mark -
#pragma mark -

//: @implementation AFJSONResponseSerializer
@implementation AFJSONResponseSerializer

//: - (void)encodeWithCoder:(NSCoder *)coder {
- (void)encodeWithCoder:(NSCoder *)coder {
    //: [super encodeWithCoder:coder];
    [super encodeWithCoder:coder];

    //: [coder encodeObject:@(self.readingOptions) forKey:NSStringFromSelector(@selector(readingOptions))];
    [coder encodeObject:@(self.wishWatching) forKey:NSStringFromSelector(@selector(wishWatching))];
    //: [coder encodeObject:@(self.removesKeysWithNullValues) forKey:NSStringFromSelector(@selector(removesKeysWithNullValues))];
    [coder encodeObject:@(self.contrastSunOwnerred) forKey:NSStringFromSelector(@selector(contrastSunOwnerred))];
}

//: + (instancetype)serializer {
+ (instancetype)unit {
    //: return [self serializerWithReadingOptions:(NSJSONReadingOptions)0];
    return [self realm:(NSJSONReadingOptions)0];
}

//: #pragma mark - NSCopying
#pragma mark - NSCopying

//: - (instancetype)copyWithZone:(NSZone *)zone {
- (instancetype)copyWithZone:(NSZone *)zone {
    //: AFJSONResponseSerializer *serializer = [super copyWithZone:zone];
    AFJSONResponseSerializer *serializer = [super copyWithZone:zone];
    //: serializer.readingOptions = self.readingOptions;
    serializer.wishWatching = self.wishWatching;
    //: serializer.removesKeysWithNullValues = self.removesKeysWithNullValues;
    serializer.contrastSunOwnerred = self.contrastSunOwnerred;

    //: return serializer;
    return serializer;
}

//: + (instancetype)serializerWithReadingOptions:(NSJSONReadingOptions)readingOptions {
+ (instancetype)realm:(NSJSONReadingOptions)readingOptions {
    //: AFJSONResponseSerializer *serializer = [[self alloc] init];
    AFJSONResponseSerializer *serializer = [[self alloc] init];
    //: serializer.readingOptions = readingOptions;
    serializer.wishWatching = readingOptions;

    //: return serializer;
    return serializer;
}

//: - (instancetype)init {
- (instancetype)init {
    //: self = [super init];
    self = [super init];
    //: if (!self) {
    if (!self) {
        //: return nil;
        return nil;
    }

    //: self.acceptableContentTypes = [NSSet setWithObjects:@"application/json", @"text/json", @"text/javascript", nil];
    self.identifyFirsting = [NSSet setWithObjects:[TransformData sharedInstance].widgetCableResource, [TransformData sharedInstance].kTrainConfig, [TransformData sharedInstance].k_worthBuildMessage, nil];

    //: return self;
    return self;
}

//: #pragma mark - AFURLResponseSerialization
#pragma mark - AFURLResponseSerialization

//: - (id)responseObjectForResponse:(NSURLResponse *)response
- (id)occasion:(NSURLResponse *)response
                           //: data:(NSData *)data
                           belowArenaRaw:(NSData *)data
                          //: error:(NSError *__autoreleasing *)error
                          footAround:(NSError *__autoreleasing *)error
{
    //: if (![self validateResponse:(NSHTTPURLResponse *)response data:data error:error]) {
    if (![self filter:(NSHTTPURLResponse *)response dry:data fresh:error]) {
        //: if (!error || AFErrorOrUnderlyingErrorHasCodeInDomain(*error, NSURLErrorCannotDecodeContentData, AFURLResponseSerializationErrorDomain)) {
        if (!error || robotVideo(*error, NSURLErrorCannotDecodeContentData, globalCleanKey(nil))) {
            //: return nil;
            return nil;
        }
    }

    // Workaround for behavior of Rails to return a single space for `head :ok` (a workaround for a bug in Safari), which is not interpreted as valid input by NSJSONSerialization.
    // See https://github.com/rails/rails/issues/1742
    //: BOOL isSpace = [data isEqualToData:[NSData dataWithBytes:" " length:1]];
    BOOL isSpace = [data isEqualToData:[NSData dataWithBytes:" " length:1]];

    //: if (data.length == 0 || isSpace) {
    if (data.length == 0 || isSpace) {
        //: return nil;
        return nil;
    }

    //: NSError *serializationError = nil;
    NSError *serializationError = nil;

    //: id responseObject = [NSJSONSerialization JSONObjectWithData:data options:self.readingOptions error:&serializationError];
    id responseObject = [NSJSONSerialization JSONObjectWithData:data options:self.wishWatching error:&serializationError];

    //: if (!responseObject)
    if (!responseObject)
    {
        //: if (error) {
        if (error) {
            //: *error = AFErrorWithUnderlyingError(serializationError, *error);
            *error = translatePlayer(serializationError, *error);
        }
        //: return nil;
        return nil;
    }

    //: if (self.removesKeysWithNullValues) {
    if (self.contrastSunOwnerred) {
        //: return AFJSONObjectByRemovingKeysWithNullValues(responseObject, self.readingOptions);
        return quantityeractionOperate(responseObject, self.wishWatching);
    }

    //: return responseObject;
    return responseObject;
}

//: #pragma mark - NSSecureCoding
#pragma mark - NSSecureCoding

//: + (BOOL)supportsSecureCoding {
+ (BOOL)supportsSecureCoding {
    //: return YES;
    return YES;
}

//: - (instancetype)initWithCoder:(NSCoder *)decoder {
- (instancetype)initWithCoder:(NSCoder *)decoder {
    //: self = [super initWithCoder:decoder];
    self = [super initWithCoder:decoder];
    //: if (!self) {
    if (!self) {
        //: return nil;
        return nil;
    }

    //: self.readingOptions = [[decoder decodeObjectOfClass:[NSNumber class] forKey:NSStringFromSelector(@selector(readingOptions))] unsignedIntegerValue];
    self.wishWatching = [[decoder decodeObjectOfClass:[NSNumber class] forKey:NSStringFromSelector(@selector(wishWatching))] unsignedIntegerValue];
    //: self.removesKeysWithNullValues = [[decoder decodeObjectOfClass:[NSNumber class] forKey:NSStringFromSelector(@selector(removesKeysWithNullValues))] boolValue];
    self.contrastSunOwnerred = [[decoder decodeObjectOfClass:[NSNumber class] forKey:NSStringFromSelector(@selector(contrastSunOwnerred))] boolValue];

    //: return self;
    return self;
}

//: @end
@end

//: #pragma mark -
#pragma mark -

//: @implementation AFXMLParserResponseSerializer
@implementation AFXMLParserResponseSerializer

//: - (instancetype)init {
- (instancetype)init {
    //: self = [super init];
    self = [super init];
    //: if (!self) {
    if (!self) {
        //: return nil;
        return nil;
    }

    //: self.acceptableContentTypes = [[NSSet alloc] initWithObjects:@"application/xml", @"text/xml", nil];
    self.identifyFirsting = [[NSSet alloc] initWithObjects:[TransformData sharedInstance].styleWealthyTimer, [TransformData sharedInstance].layoutImprovedDistinctivePreference, nil];

    //: return self;
    return self;
}

//: #pragma mark - AFURLResponseSerialization
#pragma mark - AFURLResponseSerialization

//: - (id)responseObjectForResponse:(NSHTTPURLResponse *)response
- (id)occasion:(NSHTTPURLResponse *)response
                           //: data:(NSData *)data
                           belowArenaRaw:(NSData *)data
                          //: error:(NSError *__autoreleasing *)error
                          footAround:(NSError *__autoreleasing *)error
{
    //: if (![self validateResponse:(NSHTTPURLResponse *)response data:data error:error]) {
    if (![self filter:(NSHTTPURLResponse *)response dry:data fresh:error]) {
        //: if (!error || AFErrorOrUnderlyingErrorHasCodeInDomain(*error, NSURLErrorCannotDecodeContentData, AFURLResponseSerializationErrorDomain)) {
        if (!error || robotVideo(*error, NSURLErrorCannotDecodeContentData, globalCleanKey(nil))) {
            //: return nil;
            return nil;
        }
    }

    //: return [[NSXMLParser alloc] initWithData:data];
    return [[NSXMLParser alloc] initWithData:data];
}

//: + (instancetype)serializer {
+ (instancetype)unit {
    //: AFXMLParserResponseSerializer *serializer = [[self alloc] init];
    AFXMLParserResponseSerializer *serializer = [[self alloc] init];

    //: return serializer;
    return serializer;
}

//: @end
@end

//: #pragma mark -
#pragma mark -
//: #pragma mark -
#pragma mark -

//: @implementation AFPropertyListResponseSerializer
@implementation AFPropertyListResponseSerializer

//: #pragma mark - NSSecureCoding
#pragma mark - NSSecureCoding

//: + (BOOL)supportsSecureCoding {
+ (BOOL)supportsSecureCoding {
    //: return YES;
    return YES;
}

//: #pragma mark - NSCopying
#pragma mark - NSCopying

//: - (instancetype)copyWithZone:(NSZone *)zone {
- (instancetype)copyWithZone:(NSZone *)zone {
    //: AFPropertyListResponseSerializer *serializer = [super copyWithZone:zone];
    AFPropertyListResponseSerializer *serializer = [super copyWithZone:zone];
    //: serializer.format = self.format;
    serializer.argumentWeaved = self.argumentWeaved;
    //: serializer.readOptions = self.readOptions;
    serializer.nameLefts = self.nameLefts;

    //: return serializer;
    return serializer;
}

//: #pragma mark - AFURLResponseSerialization
#pragma mark - AFURLResponseSerialization

//: - (id)responseObjectForResponse:(NSURLResponse *)response
- (id)occasion:(NSURLResponse *)response
                           //: data:(NSData *)data
                           belowArenaRaw:(NSData *)data
                          //: error:(NSError *__autoreleasing *)error
                          footAround:(NSError *__autoreleasing *)error
{
    //: if (![self validateResponse:(NSHTTPURLResponse *)response data:data error:error]) {
    if (![self filter:(NSHTTPURLResponse *)response dry:data fresh:error]) {
        //: if (!error || AFErrorOrUnderlyingErrorHasCodeInDomain(*error, NSURLErrorCannotDecodeContentData, AFURLResponseSerializationErrorDomain)) {
        if (!error || robotVideo(*error, NSURLErrorCannotDecodeContentData, globalCleanKey(nil))) {
            //: return nil;
            return nil;
        }
    }

    //: if (!data) {
    if (!data) {
        //: return nil;
        return nil;
    }

    //: NSError *serializationError = nil;
    NSError *serializationError = nil;

    //: id responseObject = [NSPropertyListSerialization propertyListWithData:data options:self.readOptions format:NULL error:&serializationError];
    id responseObject = [NSPropertyListSerialization propertyListWithData:data options:self.nameLefts format:NULL error:&serializationError];

    //: if (!responseObject)
    if (!responseObject)
    {
        //: if (error) {
        if (error) {
            //: *error = AFErrorWithUnderlyingError(serializationError, *error);
            *error = translatePlayer(serializationError, *error);
        }
        //: return nil;
        return nil;
    }

    //: return responseObject;
    return responseObject;
}

//: - (instancetype)initWithCoder:(NSCoder *)decoder {
- (instancetype)initWithCoder:(NSCoder *)decoder {
    //: self = [super initWithCoder:decoder];
    self = [super initWithCoder:decoder];
    //: if (!self) {
    if (!self) {
        //: return nil;
        return nil;
    }

    //: self.format = (NSPropertyListFormat)[[decoder decodeObjectOfClass:[NSNumber class] forKey:NSStringFromSelector(@selector(format))] unsignedIntegerValue];
    self.argumentWeaved = (NSPropertyListFormat)[[decoder decodeObjectOfClass:[NSNumber class] forKey:NSStringFromSelector(@selector(argumentWeaved))] unsignedIntegerValue];
    //: self.readOptions = [[decoder decodeObjectOfClass:[NSNumber class] forKey:NSStringFromSelector(@selector(readOptions))] unsignedIntegerValue];
    self.nameLefts = [[decoder decodeObjectOfClass:[NSNumber class] forKey:NSStringFromSelector(@selector(nameLefts))] unsignedIntegerValue];

    //: return self;
    return self;
}

//: - (instancetype)init {
- (instancetype)init {
    //: self = [super init];
    self = [super init];
    //: if (!self) {
    if (!self) {
        //: return nil;
        return nil;
    }

    //: self.acceptableContentTypes = [[NSSet alloc] initWithObjects:@"application/x-plist", nil];
    self.identifyFirsting = [[NSSet alloc] initWithObjects:[TransformData sharedInstance].globalMonsterMagicCreateerNumber, nil];

    //: return self;
    return self;
}

//: - (void)encodeWithCoder:(NSCoder *)coder {
- (void)encodeWithCoder:(NSCoder *)coder {
    //: [super encodeWithCoder:coder];
    [super encodeWithCoder:coder];

    //: [coder encodeObject:@(self.format) forKey:NSStringFromSelector(@selector(format))];
    [coder encodeObject:@(self.argumentWeaved) forKey:NSStringFromSelector(@selector(argumentWeaved))];
    //: [coder encodeObject:@(self.readOptions) forKey:NSStringFromSelector(@selector(readOptions))];
    [coder encodeObject:@(self.nameLefts) forKey:NSStringFromSelector(@selector(nameLefts))];
}

//: + (instancetype)serializerWithFormat:(NSPropertyListFormat)format
+ (instancetype)detect:(NSPropertyListFormat)format
                         //: readOptions:(NSPropertyListReadOptions)readOptions
                         agreementOpinion:(NSPropertyListReadOptions)readOptions
{
    //: AFPropertyListResponseSerializer *serializer = [[self alloc] init];
    AFPropertyListResponseSerializer *serializer = [[self alloc] init];
    //: serializer.format = format;
    serializer.argumentWeaved = format;
    //: serializer.readOptions = readOptions;
    serializer.nameLefts = readOptions;

    //: return serializer;
    return serializer;
}

//: + (instancetype)serializer {
+ (instancetype)unit {
    //: return [self serializerWithFormat:NSPropertyListXMLFormat_v1_0 readOptions:0];
    return [self detect:NSPropertyListXMLFormat_v1_0 agreementOpinion:0];
}

//: @end
@end

//: #pragma mark -
#pragma mark -





//: @interface UIImage (AFNetworkingSafeImageLoading)
@interface UIImage (AFNetworkingSafeImageLoading)
//: + (UIImage *)af_safeImageWithData:(NSData *)data;
+ (UIImage *)carrier:(NSData *)data;
//: @end
@end

//: static NSLock* imageLock = nil;
static NSLock* k_jetName = nil;

//: @implementation UIImage (AFNetworkingSafeImageLoading)
@implementation UIImage (AFNetworkingSafeImageLoading)

//: + (UIImage *)af_safeImageWithData:(NSData *)data {
+ (UIImage *)carrier:(NSData *)data {
    //: UIImage* image = nil;
    UIImage* image = nil;
    //: static dispatch_once_t onceToken;
    static dispatch_once_t onceToken;
    //: _dispatch_once(&onceToken, ^{
    _dispatch_once(&onceToken, ^{
        //: imageLock = [[NSLock alloc] init];
        k_jetName = [[NSLock alloc] init];
    //: });
    });

    //: [imageLock lock];
    [k_jetName lock];
    //: image = [UIImage imageWithData:data];
    image = [UIImage imageWithData:data];
    //: [imageLock unlock];
    [k_jetName unlock];
    //: return image;
    return image;
}

//: @end
@end

//: static UIImage * AFImageWithDataAtScale(NSData *data, CGFloat scale) {
static UIImage * trendNeat(NSData *data, CGFloat scale) {
    //: UIImage *image = [UIImage af_safeImageWithData:data];
    UIImage *image = [UIImage carrier:data];
    //: if (image.images) {
    if (image.images) {
        //: return image;
        return image;
    }

    //: return [[UIImage alloc] initWithCGImage:[image CGImage] scale:scale orientation:image.imageOrientation];
    return [[UIImage alloc] initWithCGImage:[image CGImage] scale:scale orientation:image.imageOrientation];
}

//: static UIImage * AFInflatedImageFromResponseWithDataAtScale(NSHTTPURLResponse *response, NSData *data, CGFloat scale) {
static UIImage * masterText(NSHTTPURLResponse *response, NSData *data, CGFloat scale) {
    //: if (!data || [data length] == 0) {
    if (!data || [data length] == 0) {
        //: return nil;
        return nil;
    }

    //: CGImageRef imageRef = NULL;
    CGImageRef imageRef = NULL;
    //: CGDataProviderRef dataProvider = CGDataProviderCreateWithCFData((__bridge CFDataRef)data);
    CGDataProviderRef dataProvider = CGDataProviderCreateWithCFData((__bridge CFDataRef)data);

    //: if ([response.MIMEType isEqualToString:@"image/png"]) {
    if ([response.MIMEType isEqualToString:[TransformData sharedInstance].layoutTurnDriverName]) {
        //: imageRef = CGImageCreateWithPNGDataProvider(dataProvider, NULL, true, kCGRenderingIntentDefault);
        imageRef = CGImageCreateWithPNGDataProvider(dataProvider, NULL, true, kCGRenderingIntentDefault);
    //: } else if ([response.MIMEType isEqualToString:@"image/jpeg"]) {
    } else if ([response.MIMEType isEqualToString:[TransformData sharedInstance].styleIdentifyConfig]) {
        //: imageRef = CGImageCreateWithJPEGDataProvider(dataProvider, NULL, true, kCGRenderingIntentDefault);
        imageRef = CGImageCreateWithJPEGDataProvider(dataProvider, NULL, true, kCGRenderingIntentDefault);

        //: if (imageRef) {
        if (imageRef) {
            //: CGColorSpaceRef imageColorSpace = CGImageGetColorSpace(imageRef);
            CGColorSpaceRef imageColorSpace = CGImageGetColorSpace(imageRef);
            //: CGColorSpaceModel imageColorSpaceModel = CGColorSpaceGetModel(imageColorSpace);
            CGColorSpaceModel imageColorSpaceModel = CGColorSpaceGetModel(imageColorSpace);

            // CGImageCreateWithJPEGDataProvider does not properly handle CMKY, so fall back to AFImageWithDataAtScale
            //: if (imageColorSpaceModel == kCGColorSpaceModelCMYK) {
            if (imageColorSpaceModel == kCGColorSpaceModelCMYK) {
                //: CGImageRelease(imageRef);
                CGImageRelease(imageRef);
                //: imageRef = NULL;
                imageRef = NULL;
            }
        }
    }

    //: CGDataProviderRelease(dataProvider);
    CGDataProviderRelease(dataProvider);

    //: UIImage *image = AFImageWithDataAtScale(data, scale);
    UIImage *image = trendNeat(data, scale);
    //: if (!imageRef) {
    if (!imageRef) {
        //: if (image.images || !image) {
        if (image.images || !image) {
            //: return image;
            return image;
        }

        //: imageRef = CGImageCreateCopy([image CGImage]);
        imageRef = CGImageCreateCopy([image CGImage]);
        //: if (!imageRef) {
        if (!imageRef) {
            //: return nil;
            return nil;
        }
    }

    //: size_t width = CGImageGetWidth(imageRef);
    size_t width = CGImageGetWidth(imageRef);
    //: size_t height = CGImageGetHeight(imageRef);
    size_t height = CGImageGetHeight(imageRef);
    //: size_t bitsPerComponent = CGImageGetBitsPerComponent(imageRef);
    size_t bitsPerComponent = CGImageGetBitsPerComponent(imageRef);

    //: if (width * height > 1024 * 1024 || bitsPerComponent > 8) {
    if (width * height > 1024 * 1024 || bitsPerComponent > 8) {
        //: CGImageRelease(imageRef);
        CGImageRelease(imageRef);

        //: return image;
        return image;
    }

    // CGImageGetBytesPerRow() calculates incorrectly in iOS 5.0, so defer to CGBitmapContextCreate
    //: size_t bytesPerRow = 0;
    size_t bytesPerRow = 0;
    //: CGColorSpaceRef colorSpace = CGColorSpaceCreateDeviceRGB();
    CGColorSpaceRef colorSpace = CGColorSpaceCreateDeviceRGB();
    //: CGColorSpaceModel colorSpaceModel = CGColorSpaceGetModel(colorSpace);
    CGColorSpaceModel colorSpaceModel = CGColorSpaceGetModel(colorSpace);
    //: CGBitmapInfo bitmapInfo = CGImageGetBitmapInfo(imageRef);
    CGBitmapInfo bitmapInfo = CGImageGetBitmapInfo(imageRef);

    //: if (colorSpaceModel == kCGColorSpaceModelRGB) {
    if (colorSpaceModel == kCGColorSpaceModelRGB) {
        //: uint32_t alpha = (bitmapInfo & kCGBitmapAlphaInfoMask);
        uint32_t alpha = (bitmapInfo & kCGBitmapAlphaInfoMask);
//: #pragma clang diagnostic push
#pragma clang diagnostic push
//: #pragma clang diagnostic ignored "-Wassign-enum"
#pragma clang diagnostic ignored "-Wassign-enum"
        //: if (alpha == kCGImageAlphaNone) {
        if (alpha == kCGImageAlphaNone) {
            //: bitmapInfo &= ~kCGBitmapAlphaInfoMask;
            bitmapInfo &= ~kCGBitmapAlphaInfoMask;
            //: bitmapInfo |= kCGImageAlphaNoneSkipFirst;
            bitmapInfo |= kCGImageAlphaNoneSkipFirst;
        //: } else if (!(alpha == kCGImageAlphaNoneSkipFirst || alpha == kCGImageAlphaNoneSkipLast)) {
        } else if (!(alpha == kCGImageAlphaNoneSkipFirst || alpha == kCGImageAlphaNoneSkipLast)) {
            //: bitmapInfo &= ~kCGBitmapAlphaInfoMask;
            bitmapInfo &= ~kCGBitmapAlphaInfoMask;
            //: bitmapInfo |= kCGImageAlphaPremultipliedFirst;
            bitmapInfo |= kCGImageAlphaPremultipliedFirst;
        }
//: #pragma clang diagnostic pop
#pragma clang diagnostic pop
    }

    //: CGContextRef context = CGBitmapContextCreate(NULL, width, height, bitsPerComponent, bytesPerRow, colorSpace, bitmapInfo);
    CGContextRef context = CGBitmapContextCreate(NULL, width, height, bitsPerComponent, bytesPerRow, colorSpace, bitmapInfo);

    //: CGColorSpaceRelease(colorSpace);
    CGColorSpaceRelease(colorSpace);

    //: if (!context) {
    if (!context) {
        //: CGImageRelease(imageRef);
        CGImageRelease(imageRef);

        //: return image;
        return image;
    }

    //: CGContextDrawImage(context, CGRectMake(0.0f, 0.0f, width, height), imageRef);
    CGContextDrawImage(context, CGRectMake(0.0f, 0.0f, width, height), imageRef);
    //: CGImageRef inflatedImageRef = CGBitmapContextCreateImage(context);
    CGImageRef inflatedImageRef = CGBitmapContextCreateImage(context);

    //: CGContextRelease(context);
    CGContextRelease(context);

    //: UIImage *inflatedImage = [[UIImage alloc] initWithCGImage:inflatedImageRef scale:scale orientation:image.imageOrientation];
    UIImage *inflatedImage = [[UIImage alloc] initWithCGImage:inflatedImageRef scale:scale orientation:image.imageOrientation];

    //: CGImageRelease(inflatedImageRef);
    CGImageRelease(inflatedImageRef);
    //: CGImageRelease(imageRef);
    CGImageRelease(imageRef);

    //: return inflatedImage;
    return inflatedImage;
}



//: @implementation AFImageResponseSerializer
@implementation AFImageResponseSerializer

//: - (instancetype)init {
- (instancetype)init {
    //: self = [super init];
    self = [super init];
    //: if (!self) {
    if (!self) {
        //: return nil;
        return nil;
    }

    //: self.acceptableContentTypes = [[NSSet alloc] initWithObjects:@"image/tiff", @"image/jpeg", @"image/gif", @"image/png", @"image/ico", @"image/x-icon", @"image/bmp", @"image/x-bmp", @"image/x-xbitmap", @"image/x-win-bitmap", nil];
    self.identifyFirsting = [[NSSet alloc] initWithObjects:[TransformData sharedInstance].networkCivicVersion, [TransformData sharedInstance].styleIdentifyConfig, [TransformData sharedInstance].layoutHandsomeRecoverKey, [TransformData sharedInstance].layoutTurnDriverName, [TransformData sharedInstance].colorBarPreference, [TransformData sharedInstance].k_documentHelper, [TransformData sharedInstance].userLockResult, [TransformData sharedInstance].appFeatureDriverEvent, [TransformData sharedInstance].viewSheetPath, [TransformData sharedInstance].componentConnectTime, nil];


    //: self.imageScale = [[UIScreen mainScreen] scale];
    self.loopWeaks = [[UIScreen mainScreen] scale];
    //: self.automaticallyInflatesResponseImage = YES;
    self.modernOvalled = YES;





    //: return self;
    return self;
}

//: #pragma mark - AFURLResponseSerializer
#pragma mark - AFURLResponseSerializer

//: - (id)responseObjectForResponse:(NSURLResponse *)response
- (id)occasion:(NSURLResponse *)response
                           //: data:(NSData *)data
                           belowArenaRaw:(NSData *)data
                          //: error:(NSError *__autoreleasing *)error
                          footAround:(NSError *__autoreleasing *)error
{
    //: if (![self validateResponse:(NSHTTPURLResponse *)response data:data error:error]) {
    if (![self filter:(NSHTTPURLResponse *)response dry:data fresh:error]) {
        //: if (!error || AFErrorOrUnderlyingErrorHasCodeInDomain(*error, NSURLErrorCannotDecodeContentData, AFURLResponseSerializationErrorDomain)) {
        if (!error || robotVideo(*error, NSURLErrorCannotDecodeContentData, globalCleanKey(nil))) {
            //: return nil;
            return nil;
        }
    }


    //: if (self.automaticallyInflatesResponseImage) {
    if (self.modernOvalled) {
        //: return AFInflatedImageFromResponseWithDataAtScale((NSHTTPURLResponse *)response, data, self.imageScale);
        return masterText((NSHTTPURLResponse *)response, data, self.loopWeaks);
    //: } else {
    } else {
        //: return AFImageWithDataAtScale(data, self.imageScale);
        return trendNeat(data, self.loopWeaks);
    }
    //: return nil;
    return nil;
}

//: - (instancetype)initWithCoder:(NSCoder *)decoder {
- (instancetype)initWithCoder:(NSCoder *)decoder {
    //: self = [super initWithCoder:decoder];
    self = [super initWithCoder:decoder];
    //: if (!self) {
    if (!self) {
        //: return nil;
        return nil;
    }


    //: NSNumber *imageScale = [decoder decodeObjectOfClass:[NSNumber class] forKey:NSStringFromSelector(@selector(imageScale))];
    NSNumber *imageScale = [decoder decodeObjectOfClass:[NSNumber class] forKey:NSStringFromSelector(@selector(loopWeaks))];

    //: self.imageScale = [imageScale doubleValue];
    self.loopWeaks = [imageScale doubleValue];




    //: self.automaticallyInflatesResponseImage = [decoder decodeBoolForKey:NSStringFromSelector(@selector(automaticallyInflatesResponseImage))];
    self.modernOvalled = [decoder decodeBoolForKey:NSStringFromSelector(@selector(modernOvalled))];


    //: return self;
    return self;
}

//: #pragma mark - NSSecureCoding
#pragma mark - NSSecureCoding

//: + (BOOL)supportsSecureCoding {
+ (BOOL)supportsSecureCoding {
    //: return YES;
    return YES;
}

//: - (void)encodeWithCoder:(NSCoder *)coder {
- (void)encodeWithCoder:(NSCoder *)coder {
    //: [super encodeWithCoder:coder];
    [super encodeWithCoder:coder];


    //: [coder encodeObject:@(self.imageScale) forKey:NSStringFromSelector(@selector(imageScale))];
    [coder encodeObject:@(self.loopWeaks) forKey:NSStringFromSelector(@selector(loopWeaks))];
    //: [coder encodeBool:self.automaticallyInflatesResponseImage forKey:NSStringFromSelector(@selector(automaticallyInflatesResponseImage))];
    [coder encodeBool:self.modernOvalled forKey:NSStringFromSelector(@selector(modernOvalled))];

}

//: #pragma mark - NSCopying
#pragma mark - NSCopying

//: - (instancetype)copyWithZone:(NSZone *)zone {
- (instancetype)copyWithZone:(NSZone *)zone {
    //: AFImageResponseSerializer *serializer = [super copyWithZone:zone];
    AFImageResponseSerializer *serializer = [super copyWithZone:zone];


    //: serializer.imageScale = self.imageScale;
    serializer.loopWeaks = self.loopWeaks;
    //: serializer.automaticallyInflatesResponseImage = self.automaticallyInflatesResponseImage;
    serializer.modernOvalled = self.modernOvalled;


    //: return serializer;
    return serializer;
}

//: @end
@end

//: #pragma mark -
#pragma mark -

//: @interface AFCompoundResponseSerializer ()
@interface AFCompoundResponseSerializer ()
//: @property (readwrite, nonatomic, copy) NSArray *responseSerializers;
@property (readwrite, nonatomic, copy) NSArray *betweenJumpsed;
//: @end
@end

//: @implementation AFCompoundResponseSerializer
@implementation AFCompoundResponseSerializer

//: #pragma mark - AFURLResponseSerialization
#pragma mark - AFURLResponseSerialization

//: - (id)responseObjectForResponse:(NSURLResponse *)response
- (id)occasion:(NSURLResponse *)response
                           //: data:(NSData *)data
                           belowArenaRaw:(NSData *)data
                          //: error:(NSError *__autoreleasing *)error
                          footAround:(NSError *__autoreleasing *)error
{
    //: for (id <AFURLResponseSerialization> serializer in self.responseSerializers) {
    for (id <AFURLResponseSerialization> serializer in self.betweenJumpsed) {
        //: if (![serializer isKindOfClass:[AFHTTPResponseSerializer class]]) {
        if (![serializer isKindOfClass:[AFHTTPResponseSerializer class]]) {
            //: continue;
            continue;
        }

        //: NSError *serializerError = nil;
        NSError *serializerError = nil;
        //: id responseObject = [serializer responseObjectForResponse:response data:data error:&serializerError];
        id responseObject = [serializer occasion:response belowArenaRaw:data footAround:&serializerError];
        //: if (responseObject) {
        if (responseObject) {
            //: if (error) {
            if (error) {
                //: *error = AFErrorWithUnderlyingError(serializerError, *error);
                *error = translatePlayer(serializerError, *error);
            }

            //: return responseObject;
            return responseObject;
        }
    }

    //: return [super responseObjectForResponse:response data:data error:error];
    return [super occasion:response belowArenaRaw:data footAround:error];
}

//: - (void)encodeWithCoder:(NSCoder *)coder {
- (void)encodeWithCoder:(NSCoder *)coder {
    //: [super encodeWithCoder:coder];
    [super encodeWithCoder:coder];

    //: [coder encodeObject:self.responseSerializers forKey:NSStringFromSelector(@selector(responseSerializers))];
    [coder encodeObject:self.betweenJumpsed forKey:NSStringFromSelector(@selector(betweenJumpsed))];
}

//: - (instancetype)initWithCoder:(NSCoder *)decoder {
- (instancetype)initWithCoder:(NSCoder *)decoder {
    //: self = [super initWithCoder:decoder];
    self = [super initWithCoder:decoder];
    //: if (!self) {
    if (!self) {
        //: return nil;
        return nil;
    }

    //: NSSet *classes = [NSSet setWithArray:@[[NSArray class], [AFHTTPResponseSerializer <AFURLResponseSerialization> class]]];
    NSSet *classes = [NSSet setWithArray:@[[NSArray class], [AFHTTPResponseSerializer <AFURLResponseSerialization> class]]];
    //: self.responseSerializers = [decoder decodeObjectOfClasses:classes forKey:NSStringFromSelector(@selector(responseSerializers))];
    self.betweenJumpsed = [decoder decodeObjectOfClasses:classes forKey:NSStringFromSelector(@selector(betweenJumpsed))];

    //: return self;
    return self;
}

//: #pragma mark - NSCopying
#pragma mark - NSCopying

//: - (instancetype)copyWithZone:(NSZone *)zone {
- (instancetype)copyWithZone:(NSZone *)zone {
    //: AFCompoundResponseSerializer *serializer = [super copyWithZone:zone];
    AFCompoundResponseSerializer *serializer = [super copyWithZone:zone];
    //: serializer.responseSerializers = self.responseSerializers;
    serializer.betweenJumpsed = self.betweenJumpsed;

    //: return serializer;
    return serializer;
}

//: + (instancetype)compoundSerializerWithResponseSerializers:(NSArray *)responseSerializers {
+ (instancetype)healthyCustom:(NSArray *)responseSerializers {
    //: AFCompoundResponseSerializer *serializer = [[self alloc] init];
    AFCompoundResponseSerializer *serializer = [[self alloc] init];
    //: serializer.responseSerializers = responseSerializers;
    serializer.betweenJumpsed = responseSerializers;

    //: return serializer;
    return serializer;
}

//: #pragma mark - NSSecureCoding
#pragma mark - NSSecureCoding

//: + (BOOL)supportsSecureCoding {
+ (BOOL)supportsSecureCoding {
    //: return YES;
    return YES;
}

//: @end
@end
//: __SAVE__ ignore_string [1038.10,213.2,754.7]